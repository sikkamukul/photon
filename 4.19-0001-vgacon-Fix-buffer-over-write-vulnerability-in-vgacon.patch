From a677521392c1330707d35840b6bd0e4d0dccd2e9 Mon Sep 17 00:00:00 2001
From: Yunhai Zhang <zhangyunhai@nsfocus.com>
Date: Sun, 26 Jul 2020 23:23:51 -0700
Subject: [PATCH] vgacon: Fix buffer over write vulnerability in vgacon
 scrollback handling

[ This patch is not yet merged upstream. ]

There is a buffer over write in vgacon_scrollback_update:
                scr_memcpyw(vgacon_scrollback_cur->data +
                            vgacon_scrollback_cur->tail,
                            p, c->vc_size_row);

Here vgacon_scrollback_cur->data is a buffer of size
vgacon_scrollback_cur->size which is a multiple of c->vc_size_row,
vgacon_scrollback_cur->tail increase c->vc_size_row each time and reset
to zero
when reach vgacon_scrollback_cur->size. Thus, the copy does not seem to
overflow. However, c->vc_size_row can be reset by calling
ioctl(VT_RESIZE), and
a crafted new c->vc_size_row can cause the copy to overflow.

Fix it by adding an explicit check to prevent the overflow.

This fixes CVE-2020-14331.

Not-Yet-Signed-off-by: Yunhai Zhang <zhangyunhai@nsfocus.com>
[ Srivatsa: Added commit message based on bug report from Yunhai. ]
Signed-off-by: Srivatsa S. Bhat (VMware) <srivatsa@csail.mit.edu>
---
 drivers/video/console/vgacon.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/drivers/video/console/vgacon.c b/drivers/video/console/vgacon.c
index bfaa9ec4bc1f..4479f91cf362 100644
--- a/drivers/video/console/vgacon.c
+++ b/drivers/video/console/vgacon.c
@@ -251,6 +251,10 @@ static void vgacon_scrollback_update(struct vc_data *c, int t, int count)
 	p = (void *) (c->vc_origin + t * c->vc_size_row);
 
 	while (count--) {
+		if (vgacon_scrollback_cur->tail + c->vc_size_row >=
+		    vgacon_scrollback_cur->size)
+			vgacon_scrollback_cur->tail = 0;
+
 		scr_memcpyw(vgacon_scrollback_cur->data +
 			    vgacon_scrollback_cur->tail,
 			    p, c->vc_size_row);
-- 
2.17.1

